use snowflake::ProcessUniqueId;
use std::borrow::Borrow;
use std::fmt::{Debug, Formatter};
use std::marker::PhantomData;
use lazy_static::lazy_static;

lazy_static! {
  static ref EMPTY_UNIQUE_ID : ProcessUniqueId = ProcessUniqueId::new();
}

pub struct AleVec<T> {
  unique_id: ProcessUniqueId,
  generation: usize,
  vec: Vec<Data<T>>,
  len: usize,
}

// wrapper around the actual data
pub struct Data<T> {
  object: Option<T>,  // None = delete, but call drop now
  delete_later: bool, // Delete, but call drop later
}

// key that will be generated by AleVec and be given to the caller
// will identify an entry in the vec
#[derive(Debug, Eq, PartialEq)]
pub struct Key<T> {
  unique_id: ProcessUniqueId,
  generation: usize,
  index: usize,
  valid: bool,
  phantom: PhantomData<T>,
}

impl<T> AleVec<T> {
  pub fn new() -> AleVec<T> {
    AleVec {
      unique_id: ProcessUniqueId::new(),
      generation: 0,
      vec: vec![],
      len: 0,
    }
  }

  pub fn with_capacity(capacity: usize) -> AleVec<T> {
    AleVec {
      unique_id: ProcessUniqueId::new(),
      generation: 0,
      vec: Vec::with_capacity(capacity),
      len: 0,
    }
  }

  pub fn push(&mut self, t: T) -> Key<T> {
    self.vec.push(Data {
      object: Some(t),
      delete_later: false,
    });
    self.len += 1;
    Key {
      unique_id: ProcessUniqueId::new(),
      generation: self.generation,
      index: self.vec.len() - 1,
      valid: true,
      phantom: Default::default(),
    }
  }

  pub fn remove_no_drop(&mut self, key: Key<T>) {
    if key.generation != self.generation {
      return;
    }
    if !key.valid {
      return;
    }
    self.vec[key.index].delete_later = true;
    self.len -= 1;
  }

  pub fn remove_drop(&mut self, key: Key<T>) -> Option<T> {
    if key.generation != self.generation {
      return None;
    }
    if !key.valid {
      return None;
    }
    self.vec[key.index].delete_later = true;
    if let Some(obj) = self.vec[key.index].object.take() {
      self.len -= 1;
      return Some(obj);
    }
    return None;
  }

  pub fn clear(&mut self) {
    self.vec.clear();
    self.generation += 1;
    self.len = 0;
  }

  pub fn reallocate(&mut self) {
    let mut new_vec = Vec::with_capacity(self.len);
    for item in self.vec.drain(..) {
      if !item.delete_later {
        new_vec.push(item)
      }
    }
    self.vec = new_vec;
  }

  pub fn get(&self, key: Key<T>) -> Option<&T> {
    if key.generation != self.generation {
      return None;
    }
    if !key.valid {
      return None;
    }
    if key.unique_id != self.unique_id {
      return None;
    }
    return match self.vec.get(key.index) {
      None => None,
      Some(d) => {
        if d.delete_later {
          return None;
        }
        if d.object.is_none() {
          return None;
        }
        d.object.as_ref()
      }
    };
  }

  pub fn get_mut(&mut self, key: Key<T>) -> Option<&mut T> {
    if key.generation != self.generation {
      return None;
    }
    if !key.valid {
      return None;
    }
    if key.unique_id != self.unique_id {
      return None;
    }
    return match self.vec.get_mut(key.index) {
      None => None,
      Some(d) => {
        if d.delete_later {
          return None;
        }
        if d.object.is_none() {
          return None;
        }
        d.object.as_mut()
      }
    };
  }

  pub fn len(&self) -> usize {
    self.len
  }

  pub fn iter(&self) -> AleVecIter<T> {
    return AleVecIter { alevec: self, index: 0 };
  }

  pub fn iter_mut(&mut self) -> AleVecIterMut<T> {
    return AleVecIterMut { alevec: self, index: 0 };
  }

  pub fn keys_iter(&self) -> AleVecKeyIter<T> {
    return AleVecKeyIter { alevec: self, index: 0 };
  }
}

pub struct AleVecIter<'a, T> {
  alevec: &'a AleVec<T>,
  index: usize,
}

impl<'a, T> Iterator for AleVecIter<'a, T> {
  type Item = &'a T;

  fn next(&mut self) -> Option<Self::Item> {
    for i in self.index..self.alevec.vec.len() {
      let d = &self.alevec.vec[i];
      self.index += 1;
      if !d.delete_later && d.object.is_some() {
        return d.object.as_ref();
      }
    }
    None
  }
}

pub struct AleVecIterMut<'a, T> {
  alevec: &'a mut AleVec<T>,
  index: usize,
}

impl<'a, T> Iterator for AleVecIterMut<'a, T> {
  type Item = &'a mut T;

  fn next(&mut self) -> Option<Self::Item> {
    for i in self.index..self.alevec.vec.len() {
      unsafe {
        let d = self.alevec.vec.as_mut_ptr().offset(i as isize);
        self.index += 1;
        if !(*d).delete_later && (*d).object.is_some() {
          return (*d).object.as_mut();
        }
      }
    }
    None
  }
}

pub struct AleVecKeyIter<'a, T> {
  alevec: &'a AleVec<T>,
  index: usize,
}

impl<'a, T> Iterator for AleVecKeyIter<'a, T> {
  type Item = Key<T>;

  fn next(&mut self) -> Option<Self::Item> {
    for i in self.index..self.alevec.vec.len() {
      let d = &self.alevec.vec[i];
      self.index += 1;
      if !d.delete_later {
        return Some(Key {
          unique_id: ProcessUniqueId::new(),
          generation: self.alevec.generation,
          index: i,
          valid: true,
          phantom: Default::default(),
        });
      }
    }
    None
  }
}

impl<T> Clone for Key<T> {
  fn clone(&self) -> Self {
    Key {
      unique_id: ProcessUniqueId::new(),
      generation: self.generation,
      index: self.index,
      valid: self.valid,
      phantom: Default::default(),
    }
  }
}

impl<T> Key<T> {
  pub fn empty() -> Self {
    Key {
      unique_id: *EMPTY_UNIQUE_ID,
      generation: 0,
      index: 0,
      valid: false,
      phantom: Default::default(),
    }
  }
}

impl<T> Copy for Key<T> {}

#[test]
fn test_alevec() {
  let mut v = AleVec::new();
  let k1 = v.push(10);
  let k2 = v.push(20);
  let k3 = v.push(30);

  v.remove_no_drop(k2);
  assert_eq!(v.get(k2), None);
  assert_eq!(v.get(k1), Some(&10));
  assert_eq!(v.len(), 2);

  v.clear();
  assert_eq!(v.len(), 0);

  v.push(1);
  v.push(2);
  v.push(3);
  v.push(10);
  v.push(12);

  let mut result = vec![1, 2, 3, 10, 12];
  let mut ctr = 0;
  for num in v.iter() {
    assert_eq!(num, &result[ctr]);
    ctr += 1;
  }
  assert_eq!(ctr, 5);

  let mut ctr = 0;
  for num in v.iter_mut() {
    assert_eq!(num, &mut result[ctr]);
    ctr += 1;
  }
  assert_eq!(ctr, 5);

  let mut ctr = 0;
  for mut num in v.iter_mut() {
    let mut p = 20;
    num = &mut p;
    assert_eq!(num, &mut 20);
    ctr += 1;
  }

  let mut realloc_vec = AleVec::with_capacity(5);
  realloc_vec.push(1);
  let key = realloc_vec.push(2);
  realloc_vec.push(3);

  realloc_vec.remove_no_drop(key);

  assert_eq!(realloc_vec.vec.len(), 3);
  realloc_vec.reallocate();
  assert_eq!(realloc_vec.vec.len(), 2);
}

#[test]
fn test_alevec_key_iter() {
  let mut v = AleVec::new();
  let k1 = v.push(10);
  let k2 = v.push(20);
  let k3 = v.push(30);

  v.remove_no_drop(k2);

  let keys: Vec<Key<i32>> = v.keys_iter().collect();
  assert_eq!(keys[0], k1);
  assert_eq!(keys[1], k3);
}
